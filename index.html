<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolution Graphical Method</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            font-size: 13px;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        h1 {
            text-align: center;
            color: #333;
            font-size: 1.1em;
            margin: 8px 0;
            flex-shrink: 0;
        }
        .setup-container {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
            flex: 1;
        }
        #demoSection {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        #demoSection:not(.hidden) {
            display: flex;
        }
        .info-box {
            background: #e3f2fd;
            padding: 8px;
            border-radius: 6px;
            margin: 10px;
            border-left: 3px solid #2196f3;
            font-size: 0.8em;
            flex-shrink: 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px;
            flex-shrink: 0;
        }
        .controls button {
            flex: 1;
        }
        #content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 0 10px 10px 10px;
        }
        .step-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 0;
            overflow: hidden;
        }
        .step-title {
            font-size: 0.95em;
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 8px;
        }
        .step-desc {
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        .step-header {
            padding: 10px;
            flex-shrink: 0;
        }
        .graphs-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            padding: 0 10px;
        }
        .graph-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 150px;
            margin: 5px 0;
        }
        .graphs-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-height: 0;
            min-width: fit-content;
        }
        .graphs-container.two-graphs {
        }
        .graphs-container.single-graph {
        }
        .graph-title {
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        .graph {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 140px;
            overflow: hidden;
        }
        .step-footer {
            padding: 10px;
            background: #fafafa;
            border-top: 1px solid #eee;
            flex-shrink: 0;
        }
        .setup-title {
            font-size: 1em;
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 10px;
        }
        .input-group {
            margin: 8px 0;
        }
        .input-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 3px;
            color: #555;
            font-size: 0.85em;
        }
        .input-group input {
            width: 100%;
            padding: 6px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .overlay-results {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 2;
        }
        .overlay-stem {
            position: absolute;
            width: 3px;
            background: rgba(76, 175, 80, 0.4);
            bottom: 70px;
            z-index: 2;
        }
        .overlay-impulse {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid rgba(76, 175, 80, 0.6);
            background: rgba(76, 175, 80, 0.2);
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        .axis {
            position: absolute;
            background: #333;
        }
        .axis-x {
            bottom: 70px;
            left: 0;
            right: 0;
            height: 2px;
        }
        .axis-y {
            bottom: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: #ff9800;
            z-index: 5;
        }
        .axis-y-label {
            position: absolute;
            bottom: -18px;
            left: -8px;
            color: #ff9800;
            font-weight: bold;
            font-size: 0.75em;
        }
        .stem {
            position: absolute;
            width: 2px;
            background: #2196f3;
            bottom: 70px;
            z-index: 3;
        }
        .stem.flipped {
            background: #f44336;
        }
        .stem.result {
            background: #4caf50;
        }
        .impulse {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #2196f3;
            background: transparent;
            transform: translate(-50%, -50%);
            z-index: 4;
        }
        .impulse.flipped {
            border-color: #f44336;
        }
        .impulse.result {
            border-color: #4caf50;
        }
        .tick {
            position: absolute;
            width: 1px;
            height: 4px;
            background: #666;
            bottom: 68px;
        }
        .tick-label {
            position: absolute;
            bottom: 53px;
            font-size: 0.7em;
            color: #666;
            transform: translateX(-50%);
        }
        .impulse-value {
            position: absolute;
            font-size: 0.7em;
            font-weight: bold;
            color: #333;
            transform: translateX(-50%);
        }
        .mini-sequence {
            background: #f3e5f5;
            padding: 6px;
            border-radius: 4px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            text-align: center;
            border-left: 3px solid #9c27b0;
        }
        .calculation {
            background: #fff3e0;
            padding: 6px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
        }
        .result-box {
            background: #c8e6c9;
            padding: 6px;
            border-radius: 4px;
            margin-top: 8px;
            border-left: 3px solid #4caf50;
            font-size: 0.75em;
        }
        button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }
        button:hover {
            background: #1976d2;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.start-btn {
            background: #4caf50;
            padding: 10px 20px;
        }
        .highlight {
            color: #d32f2f;
            font-weight: bold;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Convolution Graphical Method</h1>
    
    <div id="setupSection" class="setup-container">
        <div class="setup-title">Configure Your Signals</div>
        
        <div class="input-group">
            <label>First Signal x[n] (comma-separated):</label>
            <input type="text" id="signal1" value="1,2,1,2">
        </div>
        
        <div class="input-group">
            <label>First Signal Starting Index (n₁):</label>
            <input type="number" id="start1" value="0">
        </div>
        
        <div class="input-group">
            <label>Second Signal h[n] (comma-separated):</label>
            <input type="text" id="signal2" value="1,2,1,2">
        </div>
        
        <div class="input-group">
            <label>Second Signal Starting Index (n₂):</label>
            <input type="number" id="start2" value="3">
        </div>
        
        <div class="info-box">
            <strong>Note:</strong> Starting index determines where the first sample appears on the n-axis.<br>
            Example: If start=3, then first sample is at n=3, second at n=4, etc.
        </div>
        
        <div style="text-align: center; margin-top: 15px;">
            <button class="start-btn" onclick="startConvolution()">Start Convolution</button>
        </div>
    </div>

    <div id="demoSection" class="hidden">
        <div class="info-box" id="signalInfo"></div>
        
        <div class="controls">
            <button id="prevBtn" onclick="changeStep(-1)">← Prev</button>
            <button onclick="resetDemo()">Reset</button>
            <button id="nextBtn" onclick="changeStep(1)">Next →</button>
        </div>

        <div id="content"></div>
    </div>

    <script>
        let currentStep = 0;
        let steps = [];
        let sig1 = [], sig2 = [], start1 = 0, start2 = 0;
        let globalFixedRange = null;

        function parseSignal(str) {
            return str.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
        }

        function startConvolution() {
            sig1 = parseSignal(document.getElementById('signal1').value);
            sig2 = parseSignal(document.getElementById('signal2').value);
            start1 = parseInt(document.getElementById('start1').value) || 0;
            start2 = parseInt(document.getElementById('start2').value) || 0;

            if (sig1.length === 0 || sig2.length === 0) {
                alert('Please enter valid signals!');
                return;
            }

            generateSteps();
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('demoSection').classList.remove('hidden');
            
            const info = document.getElementById('signalInfo');
            const outputLength = sig1.length + sig2.length - 1;
            const end1 = start1 + sig1.length - 1;
            const end2 = start2 + sig2.length - 1;
            const outputStart = start1 + start2;
            const outputEnd = end1 + end2;
            
            info.innerHTML = `
                <strong>x[n]:</strong> {${sig1.join(', ')}} from n=${start1} to n=${end1}<br>
                <strong>h[n]:</strong> {${sig2.join(', ')}} from n=${start2} to n=${end2}<br>
                <strong>Output:</strong> ${outputLength} samples from n=${outputStart} to n=${outputEnd}
            `;
            
            renderStep(0);
        }

        function generateSteps() {
            steps = [];
            const N1 = sig1.length;
            const N2 = sig2.length;
            const end1 = start1 + N1 - 1;
            const end2 = start2 + N2 - 1;
            const outputStart = start1 + start2;
            const outputEnd = end1 + end2;
            const outputLength = N1 + N2 - 1;

            const allIndices = [];
            for (let i = 0; i < N1; i++) allIndices.push(start1 + i);
            for (let i = 0; i < N2; i++) allIndices.push(start2 + i);
            
            const flippedStart = -end2;
            const flippedEnd = -start2;
            for (let i = flippedStart; i <= flippedEnd; i++) allIndices.push(i);
            
            for (let n = outputStart; n <= outputEnd; n++) {
                for (let i = 0; i < N2; i++) {
                    allIndices.push(n - start2 - i);
                }
            }
            
            const minIdx = Math.min(...allIndices);
            const maxIdx = Math.max(...allIndices);
            const range = Math.max(Math.abs(minIdx), Math.abs(maxIdx)) + 3;
            
            const allConvolutionResults = [];
            for (let n = outputStart; n <= outputEnd; n++) {
                let sum = 0;
                for (let k = start1; k <= end1; k++) {
                    const h_idx = n - k;
                    if (h_idx >= start2 && h_idx <= end2) {
                        const x_val = sig1[k - start1];
                        const h_val = sig2[h_idx - start2];
                        sum += x_val * h_val;
                    }
                }
                allConvolutionResults.push(Math.abs(sum));
            }
            
            const maxConvolutionVal = Math.max(...allConvolutionResults);
            const maxSignalVal = Math.max(...sig1.map(v => Math.abs(v)), ...sig2.map(v => Math.abs(v)));
            const globalMaxVal = Math.max(maxConvolutionVal, maxSignalVal);
            
            globalFixedRange = { min: -range, max: range, maxVal: globalMaxVal };

            steps.push({
                title: "Step 0: Original Signals",
                description: `x[n] from n=${start1} to n=${end1}, h[n] from n=${start2} to n=${end2}`,
                graphs: [
                    {
                        title: "h[n] (red)",
                        bars: sig2.map((v, i) => ({n: start2 + i, val: v})),
                        type: 'flipped'
                    },
                    {
                        title: "x[n] (blue)",
                        bars: sig1.map((v, i) => ({n: start1 + i, val: v})),
                        type: 'original'
                    }
                ]
            });

            const flippedSig2 = [...sig2].reverse();
            steps.push({
                title: "Step 1: Flip h[k] → h[-k]",
                description: `Flipping reverses the signal around the n=0 axis.`,
                graphs: [
                    {
                        title: "h[-k] (red - flipped)",
                        bars: flippedSig2.map((v, i) => ({n: -start2 - i, val: v})),
                        type: 'flipped'
                    },
                    {
                        title: "h[k] (red - original)",
                        bars: sig2.map((v, i) => ({n: start2 + i, val: v})),
                        type: 'flipped'
                    }
                ],
                calculation: `Original h[n] spans: n=${start2} to n=${end2}<br>` +
                           `After flipping h[-k], it spans: k=${flippedStart} to k=${flippedEnd}`
            });

            const result = [];
            const partialResults = [];
            
            const initialShiftedH = flippedSig2.map((v, i) => ({
                n: outputStart - start2 - i,
                val: v
            }));
            
            steps.push({
                title: `Step 2: Position h[-k] for First Output`,
                description: `The flipped signal h[-k] shifts to position n=${outputStart} to compute y[${outputStart}].<br>` +
                           `Initial shift position = n₁ + n₂ = ${start1} + ${start2} = ${outputStart}`,
                graphs: [
                    {
                        title: "h[-k] (red - before shifting)",
                        bars: flippedSig2.map((v, i) => ({n: -start2 - i, val: v})),
                        type: 'flipped'
                    },
                    {
                        title: `h[${outputStart}-k] (red - after shifting to n=${outputStart})`,
                        bars: initialShiftedH,
                        type: 'flipped'
                    }
                ],
                calculation: `Starting position for convolution:<br>` +
                           `Output begins at n = n₁ + n₂ = ${start1} + ${start2} = ${outputStart}`
            });
            
            for (let n = outputStart; n <= outputEnd; n++) {
                let sum = 0;
                let calcText = [];

                for (let k = start1; k <= end1; k++) {
                    const h_idx = n - k;
                    
                    if (h_idx >= start2 && h_idx <= end2) {
                        const x_val = sig1[k - start1];
                        const h_val = sig2[h_idx - start2];
                        sum += x_val * h_val;
                        calcText.push(`x[${k}]·h[${h_idx}]=${x_val}·${h_val}`);
                    }
                }

                result.push(sum);
                partialResults.push({n: n, val: sum});

                const shiftedH = flippedSig2.map((v, i) => ({
                    n: n - start2 - i,
                    val: v
                }));

                steps.push({
                    title: `Step ${n - outputStart + 3}: n=${n}`,
                    description: `Shift h[-k] to h[${n}-k], computing y[${n}]`,
                    graphs: [
                        {
                            title: "x[k] (blue)",
                            bars: sig1.map((v, i) => ({n: start1 + i, val: v})),
                            type: 'original'
                        },
                        {
                            title: `h[${n}-k] (red)`,
                            bars: shiftedH,
                            type: 'flipped'
                        }
                    ],
                    overlayResults: [...partialResults],
                    sequence: `y[n] so far: {${partialResults.map(p => p.val).join(', ')}}`,
                    calculation: calcText.length > 0 ? 
                        `y[${n}] = ${calcText.join(' + ')} = <span class='highlight'>${sum}</span>` :
                        `y[${n}] = <span class='highlight'>0</span> (no overlap)`,
                    result: `y[${n}] = ${sum}`
                });
            }

            steps.push({
                title: "Final Result",
                description: `Complete convolution y[n] = x[n] * h[n]`,
                graphs: [{
                    title: `y[n] (green)`,
                    bars: result.map((v, i) => ({n: outputStart + i, val: v})),
                    type: 'result'
                }],
                result: `y[n] = {${result.join(', ')}} from n=${outputStart} to n=${outputEnd}`
            });
        }

        function renderGraph(graph, container, globalRange, isSingleGraph = false, overlayResults = null) {
            const wrapper = document.createElement('div');
            wrapper.className = 'graph-wrapper';
            
            if (graph.title) {
                const title = document.createElement('div');
                title.className = 'graph-title';
                title.textContent = graph.title;
                wrapper.appendChild(title);
            }

            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph';

            const minN = globalRange.min;
            const maxN = globalRange.max;
            const range = maxN - minN + 1;
            
            const availableWidth = window.innerWidth - 60;
            const minSpacing = 20;
            const maxSpacing = 50;
            let spacing = Math.max(minSpacing, Math.min(maxSpacing, availableWidth / (range + 1)));

            const axisX = document.createElement('div');
            axisX.className = 'axis axis-x';
            graphDiv.appendChild(axisX);

            const axisY = document.createElement('div');
            axisY.className = 'axis axis-y';
            axisY.style.left = ((0 - minN) * spacing + spacing/2) + 'px';
            const yLabel = document.createElement('div');
            yLabel.className = 'axis-y-label';
            yLabel.textContent = 'n=0';
            axisY.appendChild(yLabel);
            graphDiv.appendChild(axisY);

            for (let i = minN; i <= maxN; i++) {
                const tick = document.createElement('div');
                tick.className = 'tick';
                tick.style.left = ((i - minN) * spacing + spacing/2) + 'px';
                graphDiv.appendChild(tick);

                const tickLabel = document.createElement('div');
                tickLabel.className = 'tick-label';
                tickLabel.textContent = i;
                tickLabel.style.left = ((i - minN) * spacing + spacing/2) + 'px';
                graphDiv.appendChild(tickLabel);
            }

            const maxVal = globalRange.maxVal;

            graph.bars.forEach(bar => {
                const x = (bar.n - minN) * spacing + spacing/2;
                const height = Math.abs(bar.val) * (50 / maxVal);
                
                const stem = document.createElement('div');
                stem.className = 'stem ' + graph.type;
                stem.style.left = (x - 1) + 'px';
                stem.style.height = height + 'px';
                if (bar.val >= 0) {
                    stem.style.bottom = '70px';
                } else {
                    stem.style.bottom = (70 - height) + 'px';
                }
                graphDiv.appendChild(stem);

                const impulse = document.createElement('div');
                impulse.className = 'impulse ' + graph.type;
                impulse.style.left = x + 'px';
                if (bar.val >= 0) {
                    impulse.style.bottom = (70 + height) + 'px';
                } else {
                    impulse.style.bottom = (70 - height) + 'px';
                }
                graphDiv.appendChild(impulse);

                const value = document.createElement('div');
                value.className = 'impulse-value';
                value.textContent = bar.val;
                value.style.left = x + 'px';
                if (bar.val >= 0) {
                    value.style.bottom = (70 + height + 10) + 'px';
                } else {
                    value.style.bottom = (70 - height - 15) + 'px';
                }
                graphDiv.appendChild(value);
            });

            if (overlayResults && overlayResults.length > 0) {
                const overlayDiv = document.createElement('div');
                overlayDiv.className = 'overlay-results';
                
                overlayResults.forEach(result => {
                    const x = (result.n - minN) * spacing + spacing/2;
                    const height = Math.abs(result.val) * (50 / maxVal);
                    
                    const stem = document.createElement('div');
                    stem.className = 'overlay-stem';
                    stem.style.left = (x - 1.5) + 'px';
                    stem.style.height = height + 'px';
                    if (result.val >= 0) {
                        stem.style.bottom = '70px';
                    } else {
                        stem.style.bottom = (70 - height) + 'px';
                    }
                    overlayDiv.appendChild(stem);
                    
                    const impulse = document.createElement('div');
                    impulse.className = 'overlay-impulse';
                    impulse.style.left = x + 'px';
                    if (result.val >= 0) {
                        impulse.style.bottom = (70 + height) + 'px';
                    } else {
                        impulse.style.bottom = (70 - height) + 'px';
                    }
                    overlayDiv.appendChild(impulse);
                });
                
                graphDiv.appendChild(overlayDiv);
            }

            wrapper.appendChild(graphDiv);
            container.appendChild(wrapper);
        }

        function renderStep(stepIndex) {
            const step = steps[stepIndex];
            const content = document.getElementById('content');
            content.innerHTML = '';

            const stepDiv = document.createElement('div');
            stepDiv.className = 'step-container';

            const stepHeader = document.createElement('div');
            stepHeader.className = 'step-header';

            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = step.title;
            stepHeader.appendChild(title);

            const desc = document.createElement('div');
            desc.className = 'step-desc';
            desc.innerHTML = step.description;
            stepHeader.appendChild(desc);

            if (step.sequence) {
                const seq = document.createElement('div');
                seq.className = 'mini-sequence';
                seq.innerHTML = step.sequence;
                stepHeader.appendChild(seq);
            }

            stepDiv.appendChild(stepHeader);

            const graphsArea = document.createElement('div');
            graphsArea.className = 'graphs-area';

            const isSingleGraph = step.graphs.length === 1;
            const graphsContainer = document.createElement('div');
            graphsContainer.className = isSingleGraph ? 'graphs-container single-graph' : 'graphs-container two-graphs';

            const minN = globalFixedRange.min;
            const maxN = globalFixedRange.max;
            const maxVal = globalFixedRange.maxVal;
            const globalRange = { min: minN, max: maxN, maxVal: maxVal };

            step.graphs.forEach((graph, index) => {
                const overlayData = (index === 1 && step.overlayResults) ? step.overlayResults : null;
                renderGraph(graph, graphsContainer, globalRange, isSingleGraph, overlayData);
            });

            graphsArea.appendChild(graphsContainer);
            stepDiv.appendChild(graphsArea);

            if (step.calculation || step.result) {
                const stepFooter = document.createElement('div');
                stepFooter.className = 'step-footer';

                if (step.calculation) {
                    const calc = document.createElement('div');
                    calc.className = 'calculation';
                    calc.innerHTML = '<strong>Calculation:</strong> ' + step.calculation;
                    stepFooter.appendChild(calc);
                }

                if (step.result) {
                    const result = document.createElement('div');
                    result.className = 'result-box';
                    result.innerHTML = '<strong>Result:</strong> ' + step.result;
                    stepFooter.appendChild(result);
                }

                stepDiv.appendChild(stepFooter);
            }

            content.appendChild(stepDiv);

            document.getElementById('prevBtn').disabled = stepIndex === 0;
            document.getElementById('nextBtn').disabled = stepIndex === steps.length - 1;
        }

        function changeStep(delta) {
            currentStep = Math.max(0, Math.min(steps.length - 1, currentStep + delta));
            renderStep(currentStep);
        }

        function resetDemo() {
            currentStep = 0;
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('demoSection').classList.add('hidden');
        }
    </script>
</body>
</html>